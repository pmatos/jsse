#!/usr/bin/env python3
"""Generate Rust source for emoji string property tables.

Produces src/emoji_strings.rs with lookup_string_property() function.
"""

import re
import sys
from pathlib import Path

CACHE = Path(__file__).parent / ".unicode_cache"


def parse_sequences(path: Path, property_name: str) -> list[list[int]]:
    """Parse emoji sequence file, returning lists of codepoints for the given property."""
    seqs = []
    for line in path.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split(";")
        if len(parts) < 2:
            continue
        prop = parts[1].strip().split()[0]  # first word
        if prop != property_name:
            continue
        cp_part = parts[0].strip()
        if ".." in cp_part:
            # Range of single codepoints
            start_s, end_s = cp_part.split("..")
            start = int(start_s.strip(), 16)
            end = int(end_s.strip(), 16)
            for cp in range(start, end + 1):
                seqs.append([cp])
        else:
            cps = [int(h.strip(), 16) for h in cp_part.split()]
            seqs.append(cps)
    return seqs


def parse_zwj_sequences(path: Path) -> list[list[int]]:
    """Parse emoji-zwj-sequences.txt, returning all ZWJ sequences."""
    seqs = []
    for line in path.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split(";")
        if len(parts) < 2:
            continue
        cp_part = parts[0].strip()
        cps = [int(h.strip(), 16) for h in cp_part.split()]
        seqs.append(cps)
    return seqs


def cps_to_rust_str(cps: list[int]) -> str:
    """Convert codepoint list to Rust string literal."""
    parts = []
    for cp in cps:
        if 0x20 <= cp <= 0x7E and cp != ord('"') and cp != ord("\\"):
            parts.append(chr(cp))
        else:
            parts.append(f"\\u{{{cp:04X}}}")
    return '"' + "".join(parts) + '"'


def main():
    seq_file = CACHE / "emoji-sequences.txt"
    zwj_file = CACHE / "emoji-zwj-sequences.txt"

    if not seq_file.exists() or not zwj_file.exists():
        print("Missing emoji data files in scripts/.unicode_cache/", file=sys.stderr)
        print("Run: curl -sL -o scripts/.unicode_cache/emoji-sequences.txt "
              "https://unicode.org/Public/emoji/16.0/emoji-sequences.txt", file=sys.stderr)
        sys.exit(1)

    # Parse all property-of-strings
    keycap = parse_sequences(seq_file, "Emoji_Keycap_Sequence")
    flag = parse_sequences(seq_file, "RGI_Emoji_Flag_Sequence")
    tag = parse_sequences(seq_file, "RGI_Emoji_Tag_Sequence")
    modifier = parse_sequences(seq_file, "RGI_Emoji_Modifier_Sequence")
    basic_single = parse_sequences(seq_file, "Basic_Emoji")  # single codepoints and pairs
    zwj = parse_zwj_sequences(zwj_file)

    # Basic_Emoji multi-codepoint sequences (the ones with FE0F presentation selector)
    basic_multi = [s for s in basic_single if len(s) > 1]
    basic_singles_only = [s for s in basic_single if len(s) == 1]

    # RGI_Emoji = union of all
    rgi_emoji_multi = []
    rgi_emoji_multi.extend(keycap)
    rgi_emoji_multi.extend(flag)
    rgi_emoji_multi.extend(tag)
    rgi_emoji_multi.extend(modifier)
    rgi_emoji_multi.extend(basic_multi)
    rgi_emoji_multi.extend(zwj)

    # Sort by longest first for greedy matching
    rgi_emoji_multi.sort(key=lambda s: (-len(s), s))

    # Deduplicate
    seen = set()
    deduped = []
    for s in rgi_emoji_multi:
        key = tuple(s)
        if key not in seen:
            seen.add(key)
            deduped.append(s)
    rgi_emoji_multi = deduped

    # Print stats
    print(f"// Emoji_Keycap_Sequence: {len(keycap)} sequences", file=sys.stderr)
    print(f"// RGI_Emoji_Flag_Sequence: {len(flag)} sequences", file=sys.stderr)
    print(f"// RGI_Emoji_Tag_Sequence: {len(tag)} sequences", file=sys.stderr)
    print(f"// RGI_Emoji_Modifier_Sequence: {len(modifier)} sequences", file=sys.stderr)
    print(f"// Basic_Emoji singles: {len(basic_singles_only)}, multi: {len(basic_multi)}", file=sys.stderr)
    print(f"// RGI_Emoji_ZWJ_Sequence: {len(zwj)} sequences", file=sys.stderr)
    print(f"// RGI_Emoji multi-codepoint total (deduped): {len(rgi_emoji_multi)}", file=sys.stderr)
    print(f"// RGI_Emoji single codepoints: {len(basic_singles_only)}", file=sys.stderr)

    # Generate Rust source
    out = []
    out.append("// AUTO-GENERATED by scripts/gen_emoji_strings.py â€” DO NOT EDIT")
    out.append("// Unicode Emoji 16.0 string property tables")
    out.append("")

    def write_array(name, seqs):
        out.append(f"pub(crate) static {name}: &[&str] = &[")
        for s in seqs:
            out.append(f"    {cps_to_rust_str(s)},")
        out.append("];")
        out.append("")

    write_array("EMOJI_KEYCAP_SEQUENCE", keycap)
    write_array("RGI_EMOJI_FLAG_SEQUENCE", flag)
    write_array("RGI_EMOJI_TAG_SEQUENCE", tag)
    write_array("RGI_EMOJI_MODIFIER_SEQUENCE", modifier)
    write_array("BASIC_EMOJI_MULTI", basic_multi)
    write_array("RGI_EMOJI_ZWJ_SEQUENCE", zwj)

    # Basic_Emoji single codepoints as ranges
    singles = sorted([s[0] for s in basic_singles_only])
    out.append("pub(crate) static BASIC_EMOJI_SINGLES: &[u32] = &[")
    for cp in singles:
        out.append(f"    0x{cp:04X},")
    out.append("];")
    out.append("")

    # Lookup function
    out.append("/// Look up a property-of-strings name, returning (single_codepoints, multi_strings).")
    out.append("/// single_codepoints is a list of u32 codepoints, multi_strings is a list of &str.")
    out.append("/// Returns None if the property name is not a recognized property-of-strings.")
    out.append("pub(crate) fn lookup_string_property(name: &str) -> Option<(&'static [u32], &'static [&'static str])> {")
    out.append("    match name {")
    out.append('        "Emoji_Keycap_Sequence" => Some((&[], EMOJI_KEYCAP_SEQUENCE)),')
    out.append('        "RGI_Emoji_Flag_Sequence" => Some((&[], RGI_EMOJI_FLAG_SEQUENCE)),')
    out.append('        "RGI_Emoji_Tag_Sequence" => Some((&[], RGI_EMOJI_TAG_SEQUENCE)),')
    out.append('        "RGI_Emoji_Modifier_Sequence" => Some((&[], RGI_EMOJI_MODIFIER_SEQUENCE)),')
    out.append('        "Basic_Emoji" => Some((BASIC_EMOJI_SINGLES, BASIC_EMOJI_MULTI)),')
    out.append('        "RGI_Emoji_ZWJ_Sequence" => Some((&[], RGI_EMOJI_ZWJ_SEQUENCE)),')
    out.append('        "RGI_Emoji" => {')
    out.append('            // RGI_Emoji is conceptually the union of all emoji properties,')
    out.append('            // but for the regex pattern we return the multi-codepoint sequences.')
    out.append('            // The single-codepoint part is handled via Basic_Emoji singles.')
    out.append('            Some((BASIC_EMOJI_SINGLES, RGI_EMOJI_MULTI))')
    out.append('        }')
    out.append('        _ => None,')
    out.append("    }")
    out.append("}")
    out.append("")

    # RGI_Emoji combined multi-codepoint list (union of all multi-codepoint sequences)
    write_array("RGI_EMOJI_MULTI", rgi_emoji_multi)

    print("\n".join(out))


if __name__ == "__main__":
    main()
